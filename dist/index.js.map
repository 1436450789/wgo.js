{"version":3,"file":"index.js","sources":["../src/SGFParser/SGFSyntaxError.ts","../src/SGFParser/SGFParser.ts","../src/Game/rules.ts","../src/types.ts","../src/Game/Position.ts","../src/Game/Game.ts","../src/index.ts"],"sourcesContent":["import SGFParser from './SGFParser';\r\n\r\n/**\r\n * Class for syntax errors in SGF string.\r\n * @ extends Error\r\n */\r\nexport class SGFSyntaxError extends Error {\r\n  // tslint:disable-next-line:variable-name\r\n  __proto__: Error;\r\n\r\n  constructor(message: string, parser?: SGFParser) {\r\n    super(message);\r\n    this.__proto__ = new.target.prototype;\r\n\r\n    // var tempError = Error.apply(this);\r\n    this.name = this.name = 'SGFSyntaxError';\r\n    this.message = message || 'There was an unspecified syntax error in the SGF';\r\n\r\n    if (parser) {\r\n      this.message += ` on line ${parser.lineNo}, char ${parser.charNo}:\\n`;\r\n      this.message += `\\t${parser.sgfString.split('\\n')[parser.lineNo - 1]}\\n`;\r\n      this.message += `\\t${Array(parser.charNo + 1).join(' ')}^`;\r\n    }\r\n  }\r\n}\r\n\r\n// a small ES5 hack because currently in ES6 you can't extend Errors\r\n// SGFSyntaxError.prototype = Object.create(Error.prototype);\r\n// SGFSyntaxError.prototype.constructor = SGFSyntaxError;\r\n\r\nexport default SGFSyntaxError;\r\n","import SGFSyntaxError from './SGFSyntaxError';\r\nimport { PropIdent, SGFProperties, SGFCollection, SGFGameTree, SGFNode } from './sgfTypes';\r\n\r\n/**\r\n * Contains methods for parsing sgf string.\r\n * @module SGFParser\r\n */\r\n\r\nconst CODE_A = 'A'.charCodeAt(0);\r\nconst CODE_Z = 'Z'.charCodeAt(0);\r\nconst CODE_WHITE_CHAR = ' '.charCodeAt(0);\r\n\r\nfunction isCharUCLetter(char: string) {\r\n  if (!char) {\r\n    return false;\r\n  }\r\n\r\n  const charCode = char.charCodeAt(0);\r\n  return charCode >= CODE_A && charCode <= CODE_Z;\r\n}\r\n\r\n/**\r\n * Class for parsing of sgf files. Can be used for parsing of SGF fragments as well.\r\n */\r\n\r\nexport default class SGFParser {\r\n  /** SGF string to be parsed */\r\n  sgfString: string;\r\n\r\n  /** Current character position */\r\n  position: number = 0;\r\n\r\n  /** Current line number */\r\n  lineNo: number = 1;\r\n\r\n  /** Current char number (on the line) */\r\n  charNo: number = 0;\r\n\r\n  /**\r\n   * Creates new instance of SGF parser with SGF loaded ready to be parsed.\r\n   * @param sgf string to parse.\r\n   */\r\n  constructor(sgf: string) {\r\n    this.sgfString = sgf;\r\n  }\r\n\r\n  /**\r\n   * Returns current significant character (ignoring whitespace characters).\r\n   * If there is end of string, return undefined.\r\n   */\r\n  protected currentChar(): string {\r\n    while (this.sgfString.charCodeAt(this.position) <= CODE_WHITE_CHAR) {\r\n      // While the character is a whitespace, increase position pointer and line and column numbers.\r\n      this.nextChar();\r\n    }\r\n\r\n    return this.sgfString[this.position];\r\n  }\r\n\r\n  /**\r\n   * Move pointer to next character and return it (including whitespace).\r\n   */\r\n  protected nextChar() {\r\n    if (this.sgfString[this.position] === '\\n') {\r\n      this.charNo = 0;\r\n      this.lineNo++;\r\n    } else {\r\n      this.charNo++;\r\n    }\r\n    this.position++;\r\n\r\n    return this.sgfString[this.position];\r\n  }\r\n\r\n  /**\r\n   * Reads current significant character and if it isn't equal with the argument, throws an error.\r\n   * Then move pointer to next character.\r\n   */\r\n  protected processChar(char: string) {\r\n    if (this.currentChar() !== char) {\r\n      throw new SGFSyntaxError(`Unexpected character ${this.currentChar()}. Character ${char} was expected.`, this);\r\n    }\r\n\r\n    return this.nextChar();\r\n  }\r\n\r\n  /**\r\n   * Parse SGF property value - `\"[\" CValueType \"]\"`.\r\n   * @param optional\r\n   */\r\n  parsePropertyValue(optional?: boolean): string {\r\n    if (optional && this.currentChar() !== '[') {\r\n      return;\r\n    }\r\n\r\n    let value = '';\r\n\r\n    // process \"[\" and read first char\r\n    let char = this.processChar('[');\r\n\r\n    while (char !== ']') {\r\n      if (!char) {\r\n        // char mustn't be undefined\r\n        throw new SGFSyntaxError('End of SGF inside of property', this);\r\n      } else if (char === '\\\\') {\r\n        // if there is character '\\' save next character\r\n        char = this.nextChar();\r\n\r\n        if (!char) {\r\n          // char have to exist of course\r\n          throw new SGFSyntaxError('End of SGF inside of property', this);\r\n        } else if (char === '\\n') {\r\n          // ignore new line, otherwise save\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // save the character\r\n      value += char;\r\n\r\n      // and move to next one\r\n      char = this.nextChar();\r\n    }\r\n\r\n    this.processChar(']');\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Reads the property identifiers (One or more UC letters) - `UcLetter { UcLetter }`.\r\n   */\r\n  parsePropertyIdent(): PropIdent {\r\n    let ident = '';\r\n\r\n    // Read current significant character\r\n    let char = this.currentChar();\r\n\r\n    if (!isCharUCLetter(char)) {\r\n      throw new SGFSyntaxError('Property identifier must consists from upper case letters.', this);\r\n    }\r\n\r\n    ident += char;\r\n\r\n    while (char = this.nextChar()) {\r\n      if (!isCharUCLetter(char)) {\r\n        break;\r\n      }\r\n\r\n      ident += char;\r\n    }\r\n\r\n    return ident as PropIdent;\r\n  }\r\n\r\n  /**\r\n   * Parses sequence of property values - `PropValue { PropValue }`.\r\n   */\r\n  parsePropertyValues() {\r\n    const values: string[] = [];\r\n    let value = this.parsePropertyValue();\r\n\r\n    if (value) {\r\n      values.push(value);\r\n    }\r\n\r\n    while (value = this.parsePropertyValue(true)) {\r\n      values.push(value);\r\n    }\r\n\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * Parses a SGF property - `PropIdent PropValue { PropValue }`.\r\n   */\r\n  parseProperty(): [PropIdent, string[]] {\r\n    if (!isCharUCLetter(this.currentChar())) {\r\n      return;\r\n    }\r\n\r\n    return [this.parsePropertyIdent(), this.parsePropertyValues()];\r\n  }\r\n\r\n  /**\r\n   * Parses a SGF node - `\";\" { Property }`.\r\n   */\r\n  parseNode(): SGFNode {\r\n    this.processChar(';');\r\n\r\n    const properties: SGFProperties = {};\r\n    let property: [PropIdent, string[]];\r\n\r\n    while (property = this.parseProperty()) {\r\n      properties[property[0]] = property[1];\r\n    }\r\n\r\n    return properties;\r\n  }\r\n\r\n  /**\r\n   * Parses a SGF Sequence - `Node { Node }`.\r\n   */\r\n  parseSequence(): SGFNode[] {\r\n    const sequence: SGFNode[] = [];\r\n\r\n    sequence.push(this.parseNode());\r\n\r\n    while (this.currentChar() === ';') {\r\n      sequence.push(this.parseNode());\r\n    }\r\n\r\n    return sequence;\r\n  }\r\n\r\n  /**\r\n   * Parses a SGF *GameTree* - `\"(\" Sequence { GameTree } \")\"`.\r\n   */\r\n  parseGameTree(): SGFGameTree {\r\n    this.processChar('(');\r\n\r\n    const sequence = this.parseSequence();\r\n    let children: SGFGameTree[] = [];\r\n\r\n    if (this.currentChar() === '(') {\r\n      children = this.parseCollection();\r\n    }\r\n\r\n    this.processChar(')');\r\n\r\n    return { sequence, children };\r\n  }\r\n\r\n  /**\r\n   * Parses a SGF *Collection* - `Collection = GameTree { GameTree }`. This is the main method for parsing SGF file.\r\n   */\r\n  parseCollection(): SGFCollection {\r\n    const gameTrees: SGFCollection = [];\r\n    gameTrees.push(this.parseGameTree());\r\n\r\n    while (this.currentChar() === '(') {\r\n      gameTrees.push(this.parseGameTree());\r\n    }\r\n\r\n    return gameTrees;\r\n  }\r\n}\r\n","/**\r\n * WGo's game engine offers to set 3 rules:\r\n *\r\n * - *checkRepeat* - one of `repeat.KO`, `repeat.ALL`, `repeat.NONE` - defines if or when a move can be repeated.\r\n * - *allowRewrite* - if set true a move can rewrite existing move (for uncommon applications)\r\n * - *allowSuicide* - if set true a suicide will be allowed (and stone will be immediately captured)\r\n *\r\n * In this module there are some common preset rule sets (Japanese, Chinese etc...).\r\n * Extend object `gameRules` if you wish to add some rule set. Names of the rules should correspond with\r\n * SGF `RU` property.\r\n */\r\n\r\nexport enum Repeating {\r\n  KO = 'KO',\r\n  ALL = 'ALL',\r\n  NONE = 'NONE',\r\n}\r\n\r\nexport interface GoRules {\r\n  repeating: Repeating;\r\n  allowRewrite: boolean;\r\n  allowSuicide: boolean;\r\n}\r\n\r\nexport const JAPANESE_RULES: GoRules = {\r\n  repeating: Repeating.KO,\r\n  allowRewrite: false,\r\n  allowSuicide: false,\r\n};\r\n\r\nexport const CHINESE_RULES: GoRules = {\r\n  repeating: Repeating.NONE,\r\n  allowRewrite: false,\r\n  allowSuicide: false,\r\n};\r\n\r\nexport const ING_RULES: GoRules = {\r\n  repeating: Repeating.NONE,\r\n  allowRewrite: false,\r\n  allowSuicide: true,\r\n};\r\n\r\nexport const NO_RULES: GoRules = {\r\n  repeating: Repeating.ALL,\r\n  allowRewrite: true,\r\n  allowSuicide: true,\r\n};\r\n\r\nexport default {\r\n  Japanese: JAPANESE_RULES,\r\n  GOE: ING_RULES,\r\n  NZ: ING_RULES,\r\n  AGA: CHINESE_RULES,\r\n  Chinese: CHINESE_RULES,\r\n};\r\n","/**\r\n * Enumeration representing stone color, can be used for representing board position.\r\n */\r\nexport enum Color {\r\n  BLACK = 1,\r\n  B = 1,\r\n  WHITE = -1,\r\n  W = -1,\r\n  EMPTY = 0,\r\n  E = 0,\r\n}\r\n\r\n/**\r\n * Simple 2 dimensional vector for referencing field on the board.\r\n */\r\nexport interface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport interface Label extends Point {\r\n  text: string;\r\n}\r\n\r\nexport interface LineSegment {\r\n  point1: Point;\r\n  point2: Point;\r\n}\r\n\r\nexport interface Label extends Point {\r\n  text: string;\r\n}\r\n\r\nexport interface Field extends Point {\r\n  c: Color;\r\n}\r\n\r\nexport interface Move extends Point {\r\n  c: Color.BLACK | Color.WHITE;\r\n}\r\n","/**\r\n * Contains implementation of go position class.\r\n * @module Position\r\n */\r\n\r\nimport { Color, Field } from '../types';\r\n\r\n// creates 2-dim array\r\nfunction createGrid<T>(size: number) {\r\n  const grid: T[][] = [];\r\n  for (let i = 0; i < size; i++) {\r\n    grid.push([]);\r\n  }\r\n  return grid;\r\n}\r\n\r\n/**\r\n * Position class represents a state of the go game in one moment in time. It is composed from a grid containing black\r\n * and white stones, capture counts, and actual turn. It is designed to be mutable.\r\n */\r\nexport default class Position {\r\n  /**\r\n\t * Size of the board.\r\n\t * @constant\r\n\t */\r\n\r\n  size: number;\r\n\r\n  /**\r\n   * One dimensional array containing stones of the position.\r\n   */\r\n  grid: Color[] = [];\r\n\r\n  /**\r\n   * Contains numbers of stones that both players captured.\r\n   *\r\n   * @property {number} black - Count of white stones captured by **black**.\r\n   * @property {number} white - Count of black stones captured by **white**.\r\n   */\r\n\r\n  capCount = {\r\n    black: 0,\r\n    white: 0,\r\n  };\r\n\r\n  /**\r\n   * Who plays next move.\r\n   */\r\n\r\n  turn: Color.BLACK | Color.WHITE = Color.BLACK;\r\n\r\n  /**\r\n   * Creates instance of position object.\r\n   *\r\n   * @alias WGo.Position\r\n   * @class\r\n   *\r\n   * @param {number} [size = 19] - Size of the board.\r\n   */\r\n  constructor(size: number = 19) {\r\n    this.size = size;\r\n\r\n    // init grid\r\n    this.clear();\r\n  }\r\n\r\n  isOnPosition(x: number, y: number) {\r\n    return x >= 0 && y >= 0 && x < this.size && y < this.size;\r\n  }\r\n\r\n  /**\r\n   * Returns stone on the given field.\r\n   *\r\n   * @param {number} x - X coordinate\r\n   * @param {number} y - Y coordinate\r\n   * @return {Color} Color\r\n   */\r\n  get(x: number, y: number): Color {\r\n    if (!this.isOnPosition(x, y)) {\r\n      return undefined;\r\n    }\r\n\r\n    return this.grid[x * this.size + y];\r\n  }\r\n\r\n  /**\r\n   * Sets stone on the given field.\r\n   *\r\n   * @param {number} x - X coordinate\r\n   * @param {number} y - Y coordinate\r\n   * @param {Color} c - Color\r\n   */\r\n  set(x: number, y: number, c: Color) {\r\n    if (!this.isOnPosition(x, y)) {\r\n      throw new TypeError('Attempt to set field outside of position.');\r\n    }\r\n\r\n    this.grid[x * this.size + y] = c;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clears the whole position (every value is set to EMPTY).\r\n   */\r\n  clear() {\r\n    for (let i = 0; i < this.size * this.size; i++) {\r\n      this.grid[i] = Color.EMPTY;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clones the whole position.\r\n   *\r\n   * @return {WGo.Position} Copy of the position.\r\n   * @todo Clone turn as well.\r\n   */\r\n\r\n  clone(): Position {\r\n    const clone = new Position(this.size);\r\n    clone.grid = this.grid.slice(0);\r\n    clone.capCount.black = this.capCount.black;\r\n    clone.capCount.white = this.capCount.white;\r\n    clone.turn = this.turn;\r\n    return clone;\r\n  }\r\n\r\n  /**\r\n   * Compares this position with another position and return object with changes\r\n   *\r\n   * @param {WGo.Position} position - Position to compare to.\r\n   * @return {Field[]} Array of different fields\r\n   */\r\n\r\n  compare(position: Position): Field[] {\r\n    if (position.size !== this.size) {\r\n      throw new TypeError('Positions of different sizes cannot be compared.');\r\n    }\r\n\r\n    const diff: Field[] = [];\r\n\r\n    for (let i = 0; i < this.size * this.size; i++) {\r\n      if (this.grid[i] !== position.grid[i]) {\r\n        diff.push({\r\n          x: Math.floor(i / this.size),\r\n          y: i % this.size,\r\n          c: position.grid[i],\r\n        });\r\n      }\r\n    }\r\n\r\n    return diff;\r\n  }\r\n\r\n  /**\r\n   * Sets stone on given coordinates and capture adjacent stones without liberties if there are any.\r\n   * If move is invalid, false is returned.\r\n   */\r\n  applyMove(x: number, y: number, c: Color = this.turn, allowSuicide = false, allowRewrite = false) {\r\n    // check if move is on empty field of the board\r\n    if (!(allowRewrite || this.get(x, y) === Color.EMPTY)) {\r\n      return false;\r\n    }\r\n\r\n    // clone position and add a stone\r\n    const prevColor = this.get(x, y);\r\n    this.set(x, y, c);\r\n\r\n    // check capturing of all surrounding stones\r\n    const capturesAbove = this.get(x, y - 1) === -c && this.captureIfNoLiberties(x, y - 1);\r\n    const capturesRight = this.get(x + 1, y) === -c && this.captureIfNoLiberties(x + 1, y);\r\n    const capturesBelow = this.get(x, y + 1) === -c && this.captureIfNoLiberties(x, y + 1);\r\n    const capturesLeft = this.get(x - 1, y) === -c && this.captureIfNoLiberties(x - 1, y);\r\n    const hasCaptured = capturesAbove || capturesRight || capturesBelow || capturesLeft;\r\n\r\n    // check suicide\r\n    if (!hasCaptured) {\r\n      if (!this.hasLiberties(x, y)) {\r\n        if (allowSuicide) {\r\n          this.capture(x, y, c);\r\n        } else {\r\n          // revert position\r\n          this.set(x, y, prevColor);\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.turn = -c;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Validate position. Position is tested from 0:0 to size:size, if there are some moves,\r\n   * that should be captured, they will be removed. Returns a new Position object.\r\n   * This position isn't modified.\r\n   */\r\n\r\n  validatePosition() {\r\n    for (let x = 0; x < this.size; x++) {\r\n      for (let y = 0; y < this.size; y++) {\r\n        this.captureIfNoLiberties(x - 1, y);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns true if stone or group on the given coordinates has at least one liberty.\r\n   */\r\n  hasLiberties(x: number, y: number, alreadyTested = createGrid(this.size), c = this.get(x, y)): boolean {\r\n    // out of the board there aren't liberties\r\n    if (!this.isOnPosition(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    // however empty field means liberty\r\n    if (this.get(x, y) === Color.EMPTY) {\r\n      return true;\r\n    }\r\n\r\n    // already tested field or stone of enemy isn't a liberty.\r\n    if (alreadyTested[x][y] || this.get(x, y) === -c) {\r\n      return false;\r\n    }\r\n\r\n    // set this field as tested\r\n    alreadyTested[x][y] = true;\r\n\r\n    // in this case we are checking our stone, if we get 4 false, it has no liberty\r\n    return (\r\n      this.hasLiberties(x, y - 1, alreadyTested, c) ||\r\n      this.hasLiberties(x, y + 1, alreadyTested, c) ||\r\n      this.hasLiberties(x - 1, y, alreadyTested, c) ||\r\n      this.hasLiberties(x + 1, y, alreadyTested, c)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Checks if specified stone/group has zero liberties and if so it captures/removes stones from the position.\r\n   */\r\n  protected captureIfNoLiberties(x: number, y: number) {\r\n    // if it has zero liberties capture it\r\n    if (!this.hasLiberties(x, y)) {\r\n      // capture stones from game\r\n      this.capture(x, y);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Captures/removes stone on specified position and all adjacent and connected stones. This method ignores liberties.\r\n   */\r\n  capture(x: number, y: number, c: Color = this.get(x, y)) {\r\n    if (this.isOnPosition(x, y) && c !== Color.EMPTY && this.get(x, y) === c) {\r\n      this.set(x, y, Color.EMPTY);\r\n\r\n      if (c === Color.BLACK) {\r\n        this.capCount.white = this.capCount.white + 1;\r\n      } else {\r\n        this.capCount.black = this.capCount.black + 1;\r\n      }\r\n\r\n      this.capture(x, y - 1, c);\r\n      this.capture(x, y + 1, c);\r\n      this.capture(x - 1, y, c);\r\n      this.capture(x + 1, y, c);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For debug purposes.\r\n   */\r\n  toString() {\r\n    const TL = '┌';\r\n    const TM = '┬';\r\n    const TR = '┐';\r\n    const ML = '├';\r\n    const MM = '┼';\r\n    const MR = '┤';\r\n    const BL = '└';\r\n    const BM = '┴';\r\n    const BR = '┘';\r\n    const BS = '●';\r\n    const WS = '○';\r\n    const HF = '─'; // horizontal fill\r\n\r\n    let output = '   ';\r\n\r\n    for (let i = 0; i < this.size; i++) {\r\n      output += i < 9 ? `${i} ` : i;\r\n    }\r\n\r\n    output += '\\n';\r\n\r\n    for (let y = 0; y < this.size; y++) {\r\n      for (let x = 0; x < this.size; x++) {\r\n        const color = this.grid[x * this.size + y];\r\n\r\n        if (x === 0) {\r\n          output += `${(y < 10 ? ` ${y}` : y)} `;\r\n        }\r\n\r\n        if (color !== Color.EMPTY) {\r\n          output += color === Color.BLACK ? BS : WS;\r\n        } else {\r\n          let char;\r\n\r\n          if (y === 0) {\r\n            // top line\r\n            if (x === 0) {\r\n              char = TL;\r\n            } else if (x < this.size - 1) {\r\n              char = TM;\r\n            } else {\r\n              char = TR;\r\n            }\r\n          } else if (y < this.size - 1) {\r\n            // middle line\r\n            if (x === 0) {\r\n              char = ML;\r\n            } else if (x < this.size - 1) {\r\n              char = MM;\r\n            } else {\r\n              char = MR;\r\n            }\r\n          } else {\r\n            // bottom line\r\n            if (x === 0) {\r\n              char = BL;\r\n            } else if (x < this.size - 1) {\r\n              char = BM;\r\n            } else {\r\n              char = BR;\r\n            }\r\n          }\r\n\r\n          output += char;\r\n        }\r\n\r\n        if (x === this.size - 1) {\r\n          if (y !== this.size - 1) {\r\n            output += '\\n';\r\n          }\r\n        } else {\r\n          output += HF;\r\n        }\r\n      }\r\n    }\r\n\r\n    return output;\r\n  }\r\n\r\n  /**\r\n   * Returns position grid as two dimensional array.\r\n   */\r\n  toTwoDimensionalArray() {\r\n    const arr: Color[][] = [];\r\n\r\n    for (let x = 0; x < this.size; x++) {\r\n      arr[x] = [];\r\n      for (let y = 0; y < this.size; y++) {\r\n        arr[x][y] = this.grid[x * this.size + y];\r\n      }\r\n    }\r\n\r\n    return arr;\r\n  }\r\n}\r\n\r\n// import { Color, Field, Move } from '../types';\r\n\r\n// /**\r\n//  * Position of the board (grid) is represented as 2 dimensional array of colors.\r\n//  */\r\n// export type Position = Color[][];\r\n\r\n// /**\r\n//  * Creates empty position (filled with Color.EMPTY) of specified size.\r\n//  * @param size\r\n//  */\r\n// export function createPosition(size: number) {\r\n//   const position: Color[][] = [];\r\n//   for (let i = 0; i < size; i++) {\r\n//     const row: Color[] = [];\r\n//     for (let j = 0; j < size; j++) {\r\n//       row.push(Color.EMPTY);\r\n//     }\r\n//     position.push(row);\r\n//   }\r\n//   return position;\r\n// }\r\n\r\n// /**\r\n//  * Deep clones a position.\r\n//  * @param position\r\n//  */\r\n// export function clonePosition(position: Position) {\r\n//   return position.map(row => row.slice(0));\r\n// }\r\n\r\n// /**\r\n//  * Compares position `pos1` with position `pos2` and returns all differences on `pos2`.\r\n//  * @param pos1\r\n//  * @param pos2\r\n//  */\r\n// export function comparePositions(pos1: Position, pos2: Position): Field[] {\r\n//   if (pos1.length !== pos2.length) {\r\n//     throw new TypeError('Positions of different sizes cannot be compared.');\r\n//   }\r\n\r\n//   const diff: Field[] = [];\r\n\r\n//   for (let x = 0; x < pos1.length; x++) {\r\n//     for (let y = 0; y < pos2.length; y++) {\r\n//       if (pos1[x][y] !== pos2[x][y]) {\r\n//         diff.push({ x, y, c: pos2[x][y] });\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   return diff;\r\n// }\r\n\r\n// function isOnBoard(position: Position, x: number, y: number) {\r\n//   return x >= 0 && x < position.length && y >= 0 && y < position.length;\r\n// }\r\n\r\n// /**\r\n//  * Creates new position with specified move (with rules applied - position won't contain captured stones).\r\n//  * If move is invalid, null is returned.\r\n//  */\r\n// export function applyMove(position: Position, x: number, y: number, c: Color.B | Color.W, allowSuicide = false) {\r\n//   // check if move is on empty field of the board\r\n//   if (!isOnBoard(position, x, y) || position[x][y] !== Color.EMPTY) {\r\n//     return null;\r\n//   }\r\n\r\n//   // clone position and add a stone\r\n//   const newPosition = clonePosition(position);\r\n//   newPosition[x][y] = c;\r\n\r\n//   // check capturing of all surrounding stones\r\n//   const capturesAbove = captureIfNoLiberties(newPosition, x, y - 1, -c);\r\n//   const capturesRight = captureIfNoLiberties(newPosition, x + 1, y, -c);\r\n//   const capturesBelow = captureIfNoLiberties(newPosition, x, y + 1, -c);\r\n//   const capturesLeft = captureIfNoLiberties(newPosition, x - 1, y, -c);\r\n//   const hasCaptured = capturesAbove || capturesRight || capturesBelow || capturesLeft;\r\n\r\n//   // check suicide\r\n//   if (!hasCaptured) {\r\n//     if (!hasLiberties(newPosition, x, y)) {\r\n//       if (allowSuicide) {\r\n//         capture(newPosition, x, y, c);\r\n//       } else {\r\n//         return null;\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   return newPosition;\r\n// }\r\n\r\n// /**\r\n//  * Validate position. Position is tested from 0:0 to size:size, if there are some moves,\r\n//  * that should be captured, they will be removed. Returns a new Position object.\r\n//  */\r\n\r\n// export function getValidatedPosition(position: Position) {\r\n//   const newPosition = clonePosition(position);\r\n\r\n//   for (let x = 0; x < position.length; x++) {\r\n//     for (let y = 0; y < position.length; y++) {\r\n//       captureIfNoLiberties(newPosition, x, y);\r\n//     }\r\n//   }\r\n\r\n//   return newPosition;\r\n// }\r\n\r\n// /**\r\n//  * Capture stone or group of stones if they are zero liberties. Mutates the given position.\r\n//  *\r\n//  * @param position\r\n//  * @param x\r\n//  * @param y\r\n//  * @param c\r\n//  */\r\n// function captureIfNoLiberties(position: Position, x: number, y: number, c: Color = position[x][y]) {\r\n//   let hasCaptured = false;\r\n\r\n//   // is there a stone possible to capture?\r\n//   if (isOnBoard(position, x, y) && c !== Color.EMPTY && position[x][y] === c) {\r\n//     // if it has zero liberties capture it\r\n//     if (!hasLiberties(position, x, y)) {\r\n//       // capture stones from game\r\n//       capture(position, x, y, c);\r\n//       hasCaptured = true;\r\n//     }\r\n//   }\r\n\r\n//   return hasCaptured;\r\n// }\r\n\r\n// function createTestGrid(size: number) {\r\n//   const grid: boolean[][] = [];\r\n//   for (let i = 0; i < size; i++) {\r\n//     grid.push([]);\r\n//   }\r\n//   return grid;\r\n// }\r\n\r\n// /**\r\n//  * Returns true if stone or group on the given position has at least one liberty.\r\n//  */\r\n// function hasLiberties(\r\n//   position: Position,\r\n//   x: number,\r\n//   y: number,\r\n//   alreadyTested = createTestGrid(position.length),\r\n//   c = position[x][y],\r\n// ): boolean {\r\n//   // out of the board there aren't liberties\r\n//   if (!isOnBoard(position, x, y)) {\r\n//     return false;\r\n//   }\r\n\r\n//   // however empty field means liberty\r\n//   if (position[x][y] === Color.EMPTY) {\r\n//     return true;\r\n//   }\r\n\r\n//   // already tested field or stone of enemy isn't a liberty.\r\n//   if (alreadyTested[x][y] || position[x][y] === -c) {\r\n//     return false;\r\n//   }\r\n\r\n//   // set this field as tested\r\n//   alreadyTested[x][y] = true;\r\n\r\n//   // in this case we are checking our stone, if we get 4 false, it has no liberty\r\n//   return (\r\n//     hasLiberties(position, x, y - 1, alreadyTested, c) ||\r\n//     hasLiberties(position, x, y + 1, alreadyTested, c) ||\r\n//     hasLiberties(position, x - 1, y, alreadyTested, c) ||\r\n//     hasLiberties(position, x + 1, y, alreadyTested, c)\r\n//   );\r\n// }\r\n\r\n// /**\r\n//  * Captures/removes stone on specified position and all adjacent and connected stones. This method ignores liberties.\r\n//  * Mutates the given position.\r\n//  */\r\n// function capture(position: Position, x: number, y: number, c: Color = position[x][y]) {\r\n//   if (isOnBoard(position, x, y) && position[x][y] !== Color.EMPTY && position[x][y] === c) {\r\n//     position[x][y] = Color.EMPTY;\r\n\r\n//     capture(position, x, y - 1, c);\r\n//     capture(position, x, y + 1, c);\r\n//     capture(position, x - 1, y, c);\r\n//     capture(position, x + 1, y, c);\r\n//   }\r\n// }\r\n\r\n// /**\r\n//  * For debug purposes.\r\n//  */\r\n// export function stringifyPosition(position: Position) {\r\n//   const TL = '┌';\r\n//   const TM = '┬';\r\n//   const TR = '┐';\r\n//   const ML = '├';\r\n//   const MM = '┼';\r\n//   const MR = '┤';\r\n//   const BL = '└';\r\n//   const BM = '┴';\r\n//   const BR = '┘';\r\n//   const BS = '●';\r\n//   const WS = '○';\r\n//   const HF = '─'; // horizontal fill\r\n\r\n//   let output = '   ';\r\n\r\n//   for (let i = 0; i < position.length; i++) {\r\n//     output += i < 9 ? `${i} ` : i;\r\n//   }\r\n\r\n//   output += '\\n';\r\n\r\n//   for (let y = 0; y < position.length; y++) {\r\n//     for (let x = 0; x < position.length; x++) {\r\n//       const color = position[x][y];\r\n\r\n//       if (x === 0) {\r\n//         output += `${(y < 10 ? ` ${y}` : y)} `;\r\n//       }\r\n\r\n//       if (color !== Color.EMPTY) {\r\n//         output += color === Color.BLACK ? BS : WS;\r\n//       } else {\r\n//         let char;\r\n\r\n//         if (y === 0) {\r\n//           // top line\r\n//           if (x === 0) {\r\n//             char = TL;\r\n//           } else if (x < position.length - 1) {\r\n//             char = TM;\r\n//           } else {\r\n//             char = TR;\r\n//           }\r\n//         } else if (y < position.length - 1) {\r\n//           // middle line\r\n//           if (x === 0) {\r\n//             char = ML;\r\n//           } else if (x < position.length - 1) {\r\n//             char = MM;\r\n//           } else {\r\n//             char = MR;\r\n//           }\r\n//         } else {\r\n//           // bottom line\r\n//           if (x === 0) {\r\n//             char = BL;\r\n//           } else if (x < position.length - 1) {\r\n//             char = BM;\r\n//           } else {\r\n//             char = BR;\r\n//           }\r\n//         }\r\n\r\n//         output += char;\r\n//       }\r\n\r\n//       if (x === position.length - 1) {\r\n//         if (y !== position.length - 1) {\r\n//           output += '\\n';\r\n//         }\r\n//       } else {\r\n//         output += HF;\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   return output;\r\n// }\r\n","import { GoRules, JAPANESE_RULES, Repeating } from './rules';\r\nimport Position from './Position';\r\nimport { Color } from '../types';\r\n\r\nexport default class Game {\r\n  size: number;\r\n  rules: GoRules;\r\n  positionStack: Position[];\r\n\r\n  /**\r\n   * Creates instance of game class.\r\n   *\r\n   * @class\r\n   * This class implements game logic. It basically analyses given moves and returns capture stones.\r\n   * WGo.Game also stores every position from beginning, so it has ability to check repeating positions\r\n   * and it can effectively restore old positions.\r\n   *\r\n   *\r\n   * @param {number} [size = 19] Size of the board\r\n   * @param {string} [checkRepeat = KO] How to handle repeated position:\r\n   *\r\n   * * KO - ko is properly handled - position cannot be same like previous position\r\n   * * ALL - position cannot be same like any previous position - e.g. it forbids triple ko\r\n   * * NONE - position can be repeated\r\n   *\r\n   * @param {boolean} [allowRewrite = false] Allow to play moves, which were already played\r\n   * @param {boolean} [allowSuicide = false] Allow to play suicides, stones are immediately captured\r\n   */\r\n\r\n  constructor(size: number = 19, rules: GoRules = JAPANESE_RULES) {\r\n    this.size = size;\r\n    this.rules = rules;\r\n    this.positionStack = [new Position(size)];\r\n  }\r\n\r\n  get position() {\r\n    return this.positionStack[this.positionStack.length - 1];\r\n  }\r\n\r\n  set position(pos) {\r\n    this.positionStack[this.positionStack.length - 1] = pos;\r\n  }\r\n\r\n  get turn() {\r\n    return this.position.turn;\r\n  }\r\n\r\n  set turn(color: Color.WHITE | Color.BLACK) {\r\n    this.position.turn = color;\r\n  }\r\n\r\n  get capCount() {\r\n    return this.position.capCount;\r\n  }\r\n\r\n  /**\r\n   * Play move. You can specify color.\r\n   */\r\n  play(x: number, y: number) {\r\n    const nextPosition = this.tryToPlay(x, y);\r\n\r\n    if (nextPosition) {\r\n      this.pushPosition(nextPosition);\r\n    }\r\n\r\n    return nextPosition;\r\n  }\r\n\r\n  /**\r\n   * Tries to play on given coordinates, returns new position after the play, or error code.\r\n   */\r\n  protected tryToPlay(x: number, y: number) {\r\n    const nextPosition = this.position.clone();\r\n    const success = nextPosition.applyMove(x, y, nextPosition.turn, this.rules.allowSuicide, this.rules.allowRewrite);\r\n\r\n    if (success && !this.hasPositionRepeated(nextPosition)) {\r\n      return nextPosition;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @param {Position} position to check\r\n   * @return {boolean} Returns true if the position didn't occurred in the past (according to the rule set)\r\n   */\r\n  hasPositionRepeated(position: Position): boolean {\r\n    let depth: number;\r\n\r\n    if (this.rules.repeating === Repeating.KO && this.positionStack.length - 2 >= 0) {\r\n      depth = this.positionStack.length - 2;\r\n    } else if (this.rules.repeating === Repeating.NONE) {\r\n      depth = 0;\r\n    } else {\r\n      return false;\r\n    }\r\n\r\n    for (let i = this.positionStack.length - 1; i >= depth; i--) {\r\n      if (this.positionStack[i].compare(position).length === 0) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Play pass.\r\n   *\r\n   * @param {(BLACK|WHITE)} c color\r\n   */\r\n\r\n  pass(c: Color.BLACK | Color.WHITE = this.turn) {\r\n    const nextPosition = this.position.clone();\r\n    nextPosition.turn = -(c || this.turn);\r\n    this.pushPosition(nextPosition);\r\n  }\r\n\r\n  /**\r\n   * Finds out validity of the move.\r\n   *\r\n   * @param {number} x coordinate\r\n   * @param {number} y coordinate\r\n   * @return {boolean} true if move can be played.\r\n   */\r\n\r\n  isValid(x: number, y: number): boolean {\r\n    return !!this.tryToPlay(x, y);\r\n  }\r\n\r\n  /**\r\n   * Controls position of the move.\r\n   *\r\n   * @param {number} x coordinate\r\n   * @param {number} y coordinate\r\n   * @return {boolean} true if move is on board.\r\n   */\r\n\r\n  isOnBoard(x: number, y: number): boolean {\r\n    return this.position.isOnPosition(x, y);\r\n  }\r\n\r\n  /**\r\n   * Inserts move into current position. Use for setting position, for example in handicap game. Field must be empty.\r\n   *\r\n   * @param {number} x coordinate\r\n   * @param {number} y coordinate\r\n   * @param {Color} c color\r\n   * @return {boolean} true if operation is successful.\r\n   */\r\n\r\n  addStone(x: number, y: number, c: Color.BLACK | Color.WHITE): boolean {\r\n    if (this.isOnBoard(x, y) && this.position.get(x, y) === Color.EMPTY) {\r\n      this.position.set(x, y, c);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Removes move from current position.\r\n   *\r\n   * @param {number} x coordinate\r\n   * @param {number} y coordinate\r\n   * @return {boolean} true if operation is successful.\r\n   */\r\n\r\n  removeStone(x: number, y: number): boolean {\r\n    if (this.isOnBoard(x, y) && this.position.get(x, y) !== Color.EMPTY) {\r\n      this.position.set(x, y, Color.EMPTY);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Set or insert move of current position.\r\n   *\r\n   * @param {number} x coordinate\r\n   * @param {number} y coordinate\r\n   * @param {(BLACK|WHITE)} [c] color\r\n   * @return {boolean} true if operation is successful.\r\n   */\r\n\r\n  setStone(x: number, y: number, c: Color): boolean {\r\n    if (this.isOnBoard(x, y)) {\r\n      this.position.set(x, y, c);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get stone on given position.s\r\n   *\r\n   * @param {number} x coordinate\r\n   * @param {number} y coordinate\r\n   * @return {(Color|null)} color\r\n   */\r\n\r\n  getStone(x: any, y: any): (Color | null) {\r\n    return this.position.get(x, y);\r\n  }\r\n\r\n  /**\r\n   * Add position to stack. If position isn't specified current position is cloned and stacked.\r\n   * Pointer of actual position is moved to the new position.\r\n   *\r\n   * @param {WGo.Position} tmp position (optional)\r\n   */\r\n\r\n  pushPosition(pos: Position) {\r\n    return this.positionStack.push(pos);\r\n  }\r\n\r\n  /**\r\n   * Remove current position from stack. Pointer of actual position is moved to the previous position.\r\n   */\r\n\r\n  popPosition() {\r\n    if (this.positionStack.length > 1) {\r\n      return this.positionStack.pop();\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Removes all positions except the initial.\r\n   */\r\n\r\n  clear() {\r\n    this.positionStack = [this.positionStack[0]];\r\n  }\r\n}\r\n","// All public API is exported here\r\n\r\nexport { default as SGFParser, SGFSyntaxError } from './SGFParser';\r\nexport * from './Game';\r\n"],"names":["tslib_1.__extends","Repeating"],"mappings":"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AM;wBACL,MAAM,IAAI,EAAE,CAAC;qBACd;iBACF;aACF;YAED,OAAO,MAAM,CAAC;SACf;;;;QAKD,wCAAqB,GAArB;YACE,IAAM,GAAG,GAAc,EAAE,CAAC;YAE1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE;gBAClC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;gBACZ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE;oBAClC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;iBAC1C;aACF;YAED,OAAO,GAAG,CAAC;SACZ;QACH,eAAC;IAAD,CAAC,IAAA;IAED;IAEA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IAEA;IACA;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"}